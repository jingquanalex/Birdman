#include "Tilemap.h"

using namespace std;
using namespace glm;

// tileTexture - texture path of the tilemap
// tileSize - size of each tile texture
// mapData - A matrix of values specifying which tile to use from the texture.
// mapTileSize - Size of the tiles in game.
Tilemap::Tilemap(string tileTexture, vec2 tileSize, string mapData, vec2 mapTileSize) : Sprite()
{
	this->size = vec2(1, 1);
	this->texPath = tileTexture;
	this->tileSize = tileSize;
	this->mapTileSize = mapTileSize;
	load(mapData);
}

void Tilemap::load(string mapData)
{
	// Load tilemap texture and map.
	if (Sprite::load())
	{
		loadMap(mapData);
	}
}

// Load map data and generate vertices and texcoords for each tile.
void Tilemap::loadMap(string mapData)
{
	ifstream file(mapData);

	if (!file)
	{
		printf("Error reading mapData: %s", mapData);
		return;
	}

	// Use the parameters generated by the animation setup function.
	setupAnimation(tileSize, 0.0f);

	vector<int> rowMapValues;
	int posx = 0, posy = 0, count = 0;
	string buffer;
	while (getline(file, buffer, ','))
	{
		// Parse CSV data to extract:
		// 1. The value which is the frame index of the tilemap to use.
		// 2. The position of the frame in the matrix.

		if (buffer == "\n") break;

		// If buffer contains a new line, increment y index and reset x index.
		if (buffer.find("\n") != string::npos)
		{
			posx = 0;
			posy++;
			mapValues.push_back(rowMapValues);
			rowMapValues.clear();
		}

		// If value is -1, don't make quad at that position.
		int value = stoi(buffer);
		if (value != -1)
		{
			addQuadData(posx, posy, value);
			count++;
		}

		posx++;
		rowMapValues.push_back(value);
	}

	mapValues.push_back(rowMapValues);

	// Assign quad array data.
	quadVert = &vertices[0];
	quadCoord = &texcoords[0];
	quadCount = count * 4;
}

// Value specifies the index of the frame of the tilemap, and its position in the 
// matrix of values is relative to the tile in the game map. Map is built from top-left downwards.
void Tilemap::addQuadData(int posx, int posy, int value)
{
	// Vertices at specified posx, posy
	vertices.push_back(posx * mapTileSize.x); vertices.push_back(posy * -mapTileSize.y - mapTileSize.y); vertices.push_back(0.0f);
	vertices.push_back(posx * mapTileSize.x); vertices.push_back(posy * -mapTileSize.y); vertices.push_back(0.0f);
	vertices.push_back(posx * mapTileSize.x + mapTileSize.x); vertices.push_back(posy * -mapTileSize.y); vertices.push_back(0.0f);
	vertices.push_back(posx * mapTileSize.x + mapTileSize.x); vertices.push_back(posy * -mapTileSize.y - mapTileSize.y); vertices.push_back(0.0f);

	// Texcoord for this quad based on frame index (value). Padding is to remove the lines at the edge of sprite frame.
	vec2 padding = vec2(1 / texSize.x, 1 / texSize.y);
	texcoords.push_back(animFramesDelta.x * (value % (int)animFramesCount.x) + padding.x); texcoords.push_back(1 - animFramesDelta.y * (glm::floor(value / animFramesCount.x) + 1) + padding.y);
	texcoords.push_back(animFramesDelta.x * (value % (int)animFramesCount.x) + padding.x); texcoords.push_back(1 - animFramesDelta.y * glm::floor(value / animFramesCount.x) - padding.y);
	texcoords.push_back(animFramesDelta.x * (value % (int)animFramesCount.x + 1) - padding.x); texcoords.push_back(1 - animFramesDelta.y * glm::floor(value / animFramesCount.x) - padding.y);
	texcoords.push_back(animFramesDelta.x * (value % (int)animFramesCount.x + 1) - padding.x); texcoords.push_back(1 - animFramesDelta.y * (glm::floor(value / animFramesCount.x) + 1) + padding.y);
}

void Tilemap::update(float dt)
{
	Sprite::update(dt);
}

void Tilemap::draw()
{
	Sprite::draw();
}

void Tilemap::destroy()
{
	Sprite::destroy();
}

glm::vec2 Tilemap::getCoordAtPos(vec3 position) const
{
	if (position.x >= 0.0f && position.y <= 0.0f)
	{
		return vec2(floor(position.x / mapTileSize.x), floor(-position.y / mapTileSize.y));
	}
	return vec2(-1, -1);
}

// Return value of -2 is undefined.
int Tilemap::getValueAtCoord(int x, int y) const
{
	if (y >= 0 && y < mapValues.size() && x >= 0 && x < mapValues[y].size())
	{
		return mapValues[y][x];
	}
	else
	{
		return -2;
	}
}

int Tilemap::getValueAtCoord(vec2 coord) const
{
	return getValueAtCoord((int)coord.x, (int)coord.y);
}

int Tilemap::getValueAtPos(vec3 position) const
{
	return getValueAtCoord(getCoordAtPos(position));
}

vec3 Tilemap::getPositionAtCoord(int x, int y) const
{
	return vec3(mapTileSize.x * x, -mapTileSize.y * y, 0);
}

vec3 Tilemap::getPositionAtCoord(vec2 coord) const
{
	return getPositionAtCoord(coord.x, coord.y);
}

glm::vec2 Tilemap::getMapTileSize() const
{
	return mapTileSize;
}